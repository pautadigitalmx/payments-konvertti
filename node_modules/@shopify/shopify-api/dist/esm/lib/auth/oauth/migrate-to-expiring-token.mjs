import { throwFailedRequest } from '../../clients/common.mjs';
import { DataType } from '../../clients/types.mjs';
import { fetchRequestFactory } from '../../utils/fetch-request.mjs';
import { sanitizeShop } from '../../utils/shop-validator.mjs';
import { createSession } from './create-session.mjs';
import { RequestedTokenType } from './token-exchange.mjs';

const TokenExchangeGrantType = 'urn:ietf:params:oauth:grant-type:token-exchange';
function migrateToExpiringToken(config) {
    return async ({ shop, nonExpiringOfflineAccessToken, }) => {
        const body = {
            client_id: config.apiKey,
            client_secret: config.apiSecretKey,
            grant_type: TokenExchangeGrantType,
            subject_token: nonExpiringOfflineAccessToken,
            subject_token_type: RequestedTokenType.OfflineAccessToken,
            requested_token_type: RequestedTokenType.OfflineAccessToken,
            expiring: '1',
        };
        const cleanShop = sanitizeShop(config)(shop, true);
        const postResponse = await fetchRequestFactory(config)(`https://${cleanShop}/admin/oauth/access_token`, {
            method: 'POST',
            body: JSON.stringify(body),
            headers: {
                'Content-Type': DataType.JSON,
                Accept: DataType.JSON,
            },
        });
        if (!postResponse.ok) {
            throwFailedRequest(await postResponse.json(), false, postResponse);
        }
        return {
            session: createSession({
                accessTokenResponse: await postResponse.json(),
                shop: cleanShop,
                // We need to keep this as an empty string as our template DB schemas have this required
                state: '',
                config,
            }),
        };
    };
}

export { migrateToExpiringToken };
//# sourceMappingURL=migrate-to-expiring-token.mjs.map
